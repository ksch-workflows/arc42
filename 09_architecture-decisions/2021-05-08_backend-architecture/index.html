<html><head><title>Java application architecture style</title></head><body><h1>Java application architecture style</h1><hr><h2 id=context>Context</h2><p>There needs to be a concept for the module structure of the backend server.</p><h3 id=design-goals>Design goals</h3><ul><li>The business logic of the software needs to be very flexible, so that it can be adjusted to changing requirements of the KSCH.</li><li>The system needs to have good testability, so that there can be a very good test coverage for those business rules.</li><li>Enable hobby developer to contribute to the project in limited spare time. In order to achieve this, the congnitive load for working on a part of the system needs to be reduced to the minimum.</li><li>The system needs to be able to grow to support a wide range of functional requirements, so that it can potentially support all the IT based processes in the KSCH.</li></ul><h3 id=constraints>Constraints</h3><ul><li>As programming language, Java should be used, since it will most likely be supported and have a large community over the next decade.</li><li>As application framework, Spring should be used, since it allows to make rather fast progress with a very small development team.</li><li>There will be only a single process running for the backend server, i.e. no microservice architecture. The reason for this to keep the operational complexity of the system at a level where the KSCH staff might operate the system independently.</li></ul><h2 id=alternatives>Alternatives</h2><h3 id=a-gradle-based-modules>(A) Gradle based modules</h3><p>The modules may be based on Gradle&rsquo;s multi-project builds.
Every module can have two nested modules: one for the API and one for the implementation.
If one module wants to use the API of another module, it will only be able to use the classes defined in the API submodule.</p><h4 id=pros>Pros</h4><ul><li>Gradle features take care to limit cross-module access on the intended API and to avoid cyclic dependencies between modules.</li><li>It is theoretically possible to automatically render module dependendency graphs by parsing the Gradle configuration.</li><li>The system design can be understood by referencing to the Gradle documentation which is good.</li><li>Once it Gradle parts are understood, it is fairly each to introduce new modules.</li></ul><h4 id=cons>Cons</h4><ul><li>In order to add new modulues, one needs to understand the Gradle project structure and then do a dozen of steps.</li><li>Gradle makes regular breaking changes, which leads to maintenance efforts.</li><li>There is no known example for a production system which was successful using this architecture.</li><li>It is not yet clear how to manage database migrations with this architecture style.</li></ul><h4 id=references>References</h4><ul><li><a href=https://github.com/ksch-workflows/ksch-workflows>https://github.com/ksch-workflows/ksch-workflows</a></li><li><a href=https://docs.gradle.org/current/userguide/multi_project_builds.html>https://docs.gradle.org/current/userguide/multi_project_builds.html</a></li><li><a href=https://dev.to/janux_de/building-a-greenfield-hospital-information-system-with-java-spring-boot-apache-wicket-and-gradle-4np1>https://dev.to/janux_de/building-a-greenfield-hospital-information-system-with-java-spring-boot-apache-wicket-and-gradle-4np1</a></li><li><a href=https://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-creating-a-multi-project-build/>https://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-creating-a-multi-project-build/</a></li><li><a href=https://www.tutorialspoint.com/gradle/gradle_multi_project_build.htm>https://www.tutorialspoint.com/gradle/gradle_multi_project_build.htm</a></li><li><a href=https://spring.io/guides/gs/multi-module/>https://spring.io/guides/gs/multi-module/</a></li></ul><h3 id=b-modulith>(B) Modulith</h3><p>The Moduliths project is an experimental approach to achieve a good modularization for monolithic Spring applications by <a href=https://github.com/odrotbohm>Oliver Drotbohm</a>.</p><h4 id=pros-1>Pros</h4><ul><li>There is a low risk of the &ldquo;Architect&rsquo;s Ivory Tower&rdquo; where there is a &ldquo;Lack of Transparency&rdquo; of the system&rsquo;s architecture and a &ldquo;Lack of Understanding&rdquo; from the developers (see Knoernschild, p. 30 ff.).</li><li>The concept addresses many common architectural problems: cyclic dendencies, complexity, &mldr;</li></ul><h4 id=cons-1>Cons</h4><ul><li>Learning efforts for Maven and ArcUnit.</li><li>Using this approach creates a depencency on a one-person project which might be abandoned at any time.</li><li>The README introduces the project as &ldquo;A playground to build technology supporting the development of modular monolithic (modulithic) Java applications.&rdquo; So it looks rather like an experimentation ground than an estabilished pattern for production systems.</li><li>It relies on conventions enforced by ArchUnit to provide access control. The api/implementation destincition from Gradle might make it clearer what is intended to be accessible or not.</li><li>It assumes that the whole application is living a in a single Java package. The modules are then defined as subpackages. This creation a weaker demarkation line for modules than Maven or Gradle sub-projects.</li></ul><h4 id=references-1>References</h4><ul><li><a href=https://github.com/odrotbohm/moduliths>https://github.com/odrotbohm/moduliths</a></li><li><a href="https://www.youtube.com/results?search_query=modulith+drotbohm">https://www.youtube.com/results?search_query=modulith+drotbohm</a></li><li><a href=https://github.com/st-tu-dresden/salespoint>https://github.com/st-tu-dresden/salespoint</a></li><li>Knoernschild: Java Application Architecture, Kirk Knoernschild</li></ul><h3 id=c-buckpal>(C) Buckpal</h3><p>The Buckpal project is a reference implementation of the clean architecture principles by <a href=https://github.com/thombergs>Tom Hombergs</a>.</p><h4 id=pros-2>Pros</h4><ul><li>Clear application structure based on the &ldquo;Hexagonal architecture&rdquo; design which may be considered as &ldquo;best practice&rdquo;.</li></ul><h4 id=cons-2>Cons</h4><ul><li>The example application is for a rather small domain. So it is not clear how this application style will scale for large domains.</li></ul><h4 id=references-2>References</h4><ul><li><a href=https://github.com/thombergs/buckpal>https://github.com/thombergs/buckpal</a></li><li><a href="https://www.amazon.de/dp/B07YFS3DNF/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1">https://www.amazon.de/dp/B07YFS3DNF/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1</a></li></ul><h3 id=d-leasing-ninja>(D) Leasing Ninja</h3><p>The Leasing Ninja project is a reference implementation of domain-driven design principles by <a href=https://github.com/hschwentner>Henning Schwentner</a>.</p><h4 id=pros-3>Pros</h4><ul><li>Clear separation of concerns</li><li>Clear modularization</li><li>Support for domain driven design principles</li></ul><h4 id=cons-3>Cons</h4><blockquote><p>Interesting advice about Java Module System by @joshbloch in Effective Java 3rd edition: &ldquo;It is too early to say whether modules will achieve widespread use outside of the JDK itself. In the meantime, it seems best to avoid them unless you have a compelling need.&rdquo; - <a href=https://twitter.com/lucianct2k2/status/1029669555055022080>twitter.com</a></p></blockquote><h4 id=references-3>References</h4><ul><li><a href=https://github.com/leasingninja/leasingninja-java-boundedcontexts-domainmodel>https://github.com/leasingninja/leasingninja-java-boundedcontexts-domainmodel</a></li><li><a href=https://leasingninja.github.io/>https://leasingninja.github.io/</a></li><li><a href=https://blog.plan99.net/is-jigsaw-good-or-is-it-wack-ec634d36dd6f>https://blog.plan99.net/is-jigsaw-good-or-is-it-wack-ec634d36dd6f</a></li><li><a href=https://trishagee.github.io/presentation/real_world_java_9/>https://trishagee.github.io/presentation/real_world_java_9/</a></li><li><a href=https://developer.ibm.com/languages/java/tutorials/java-modularity-1/>https://developer.ibm.com/languages/java/tutorials/java-modularity-1/</a></li><li>Effective Java, Edition 3, Joshua Bloch, Item 15.</li><li>reasons for low adoption of JPMS - <a href="https://youtu.be/YYvc-DNuwr8?t=1272">https://youtu.be/YYvc-DNuwr8?t=1272</a></li></ul><h3 id=e-osgi>(E) OSGi</h3><h4 id=pros-4>Pros</h4><ul><li>Strong modularization support</li><li>Enables a plugin system</li></ul><h4 id=cons-4>Cons</h4><ul><li>No direct Spring support (see <a href=https://docs.spring.io/spring-osgi/>https://docs.spring.io/spring-osgi/</a>)</li><li>Not all Java libraries cannot be used out of the box, but they need to be compiled specifically for OSGi.</li><li>High learning effort</li><li>It&rsquo;s rather a non-mainstream technologies which stands in the way for getting more developers for the system.</li></ul><h4 id=references-4>References</h4><ul><li><a href=https://en.wikipedia.org/wiki/OSGi>https://en.wikipedia.org/wiki/OSGi</a></li></ul><h2 id=decision>Decision</h2><p>A combination of option A and option D seems most promising.</p><hr><a href=/administration/imprint>Imprint</a></body></html>